
module Lambda where

all : forall a. (a -> Bool) -> [a] -> Bool
all p [] = True
all p (x::xs)
  | p x  = all p xs
  | else = False

elem : Int -> [Int] -> Bool
elem a [] = False
elem a (x::xs)
  | a == x = True
  | else   = elem a xs

append : forall a. [a] -> [a] -> [a]
append [] ys = ys
append (x::xs) ys = x :: (append xs ys)

data Var = V Nat

data Term = Var Var
          | Lit Nat
          | Lam Var Term
          | App Term Term

deleteVar : Var -> [Var] -> [Var]
deleteVar a [] = []
deleteVar a (x::xs)
  | a == x = deleteVar a xs
  | else   = x :: deleteVar a xs

fvs : Term -> [Var]
fvs (Var x) = [x]
fvs (Lit _) = []
fvs (Lam x t) = deleteVar x (fvs t)
fvs (App f t) = append (fvs f) (fvs t)

isNF : Term -> Bool
isNF (Var _) = False
isNF (Lit _) = True
isNF (Lam x t) = True
isNF (App (Var _) t) = isNF t
isNF (App (Lit _) t) = isNF t
isNF (App (Lam _ _) t) = False
isNF (App f@(App _ _) t) = isNF f && isNF t

type NF = {t:Term | isNF t}

type Env = [(Var,NF)]

defined :  Env -> Var -> Bool
defined []           x          = False
defined ((y,_)::yts) x | y == x = True
                       | else   = defined yts x

lookup : {x:Var} -> {e:Env|defined e x} -> NF
lookup x ((y,t)::yts) | y == x = t
                      | else   = lookup x yts

extend : Var -> NF -> Env -> Env
extend x t env = (x,t)::env

eval : {e:Env} -> {t:Term|all (defined e) (fvs t)} -> NF
eval env   (Var x)   = lookup x env
eval env t@(Lit _)   = t
eval env t@(Lam _ _) = t
eval env (App f@(Var _) t)   = App (eval env f) (eval env t)
eval env (App f@(Lit _) t)   = App (eval env f) (eval env t)
eval env (App   (Lam x u) t) = eval (extend x t' env) u
  where t' = eval env t
eval env (App f@(App _ _) t)
  | isNF f = App f (eval env t)
  | else   = eval env (App (eval env f) t)
