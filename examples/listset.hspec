
module ListSet where

elem : forall a. a -> [a] -> Bool
elem a [] = False
elem a (x::xs)
  | a == x = True
  | else   = elem a xs

count : Int -> [Int] -> Nat
count a [] = 0
count a (x::xs)
  | a == x = 1 + count a xs
  | else   = count a xs

delete1 : forall a. a -> [a] -> [a]
delete1 a [] = []
delete1 a (x::xs)
  | a == x = xs
  | else   = x :: delete1 a xs

delete : forall a. a -> [a] -> [a]
delete a [] = []
delete a (x::xs)
  | a == x = delete a xs
  | else   = x :: delete a xs

append : forall a. [a] -> [a] -> [a]
append [] ys = ys
append (x::xs) ys = x :: (append xs ys)

all : forall a. (a -> Bool) -> [a] -> Bool
all p [] = True
all p (x::xs)
  | p x  = all p xs
  | else = False

nub : forall a. [a] -> [a]
nub []      = []
nub (x::xs) = x :: nub (delete x xs)

lemma nub_elem = forall x xs, ~(elem x xs) ==> nub(x::xs) == x::nub xs

theorem nub_idempotent = forall xs, nub (nub xs) == nub xs

data Set = Set {l:[Int]|nub l == l}

insert : Int -> Set -> Set
insert a s@(Set xs)
  | elem a xs = s
  | else      = Set (a::xs)

union : Set -> Set -> Set
union s@(Set xs) t@(Set ys)
  = case xs of
        []   -> t
        _::_ -> case ys of
                    []   -> s
                    _::_ -> Set (nub (append xs ys))

isSubsetOf : Set -> Set -> Bool
isSubsetOf (Set xs) (Set ys) = all (\x -> elem x ys) xs
